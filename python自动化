

自动化框架结构，目录：



注意点：
（1）因为这边都是通过json传参的，格式如下所示：
  jsondata = {"limit":10,"order":"desc","page":1,"querydict":{"create_by":"王"}}
  在request.post(json=jsondata)，通过这种方式进行传递
（2）


文件上传：
    1.python调用文件发送接口（非multipart/form-data）
        file = {                                          #上传文件请求body中的最后，关于文件的值，放在这里
            "file_obj": open('test.zip','rb'),
            "Content-Type":"application/x-zip-compressed",
            "Content-Disposition":"form-data",
            "filename":"test.zip"
        
        }
        
        data = {                                          #请求body中，除了文件外的其他的所有值，填写到data中，如果没有其他值，可以不用写
            "sample_name": "37571.pcap",
            "owner_group": "/data/atp/pcap/custom/test",
            "type": "1",
            "sample_file_path": "",
            "description_file_path": "",
            # "description_file":""
        }
        
        response = requests.post(url=url, files=file, headers=headers, verify=False, data=data).text
    
    总结：headers中不要自己填写content-tpye，注意重点位置的代码，就可以了


json文件取值，通过 .get("参数名")






问题：
（1）如何封装一个python文件，可以在另一个文件中import导入

解决：比如两个文件在同一个文件夹 a 下，在1.py下导入2.py中的类，
使用from a.2 import class ，需要从a（目录名开始写）
这个地方使用相对路径，如：..2.py 的格式，导入的时候不会报错，但是在执行的时候，会报错

（2）一个查询的请求，通过requests发送不出去了，是因为被ssl拦截，通过verify=False的方式不能解决，报错中提示的urllib3。看看有没有别的方式解决

解决： （1）通过verify=False可以解决问题，只是会报一个warning，其实请求已经发送了的
       （2）相应要使用 .text 来处理一下，否则内容为空，错认为请求未发送
       （3）屏蔽warning信息：
            1. requests.packages.urllib3.disable_warnings()                             #代码写在调用请求之前
            2. urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)      #也可以关闭掉ssl的提示，但是需要先导入urllib3的包



pytest问题


pytest的整体框架是啥样的，每个文件是干嘛的，每个文件中的构造是啥样的，

待解决问题，运行时，代码自动跑的是pytest的格式，在类旁边的运行按钮，点不了是因为啥。
保证文件名字不是 *_test 或者  test_* 的就不会默认执行pytst了

json数据中有的 null 时，会报错，可以通过None替换null，可以达到同样的效果
